---
title: "Pollution en Occitanie"
author: "Tena Lahjiouj Khodri Zhu"
format: 
 revealjs :
     theme: dark

---
# Problématique 
Comment exploiter des données pour mieux visualiser un problème actuel ?

# Introduction 
::: {.incremental}
- La pollution : une préoccupation majeure
- En Occitanie
- À l'échelle des départements
- À l'échelle des villes 
- Problèmes rencontrés 
- Conclusion
:::
# En Occitanie 
## Graphiques généraux 
```{python,}
#| echo: false
#| code-summary: "Une évolution de la concentration des polluants en Occitanie"
# %%
import pandas as pd
import plotly.graph_objects as go

data = pd.read_csv("../data/Mesure_annuelle_Region_Occitanie_Polluants_Principaux.csv")
df = pd.DataFrame(data)
columns_to_drop = ['code_station', 'typologie', 'influence', 'id_poll_ue', 'unite', 'metrique', 'date_fin', 'statut_valid']
df = df.drop(columns=columns_to_drop)
grouped_df = df.groupby(['date_debut', 'nom_poll'])['valeur'].sum().reset_index()
grouped_df = grouped_df.sort_values(by=['date_debut', 'nom_poll'])
grouped_df['date_debut'] = pd.to_datetime(grouped_df['date_debut'])
grouped_df['date_debut'] = grouped_df['date_debut'].dt.year

fig = go.FigureWidget()
polluants = ['NO','NO2','NOX','O3','PM10','PM2.5']
for polluant in polluants:
    trace_data = grouped_df[grouped_df["nom_poll"] == polluant]
    fig.add_trace(
        go.Scatter(
            x=trace_data["date_debut"],
            y=trace_data["valeur"],
            mode='lines',
            name=f"Polluant = {polluant}",
        )
    )
fig.update_layout(
    template="simple_white",
    title="Polluants en fonction de l'année",
    showlegend=True,
    xaxis_title="Année",
    yaxis_title="Fréquence normalisée en ug.m-3",
)


fig.show()
```

---
Comment nous y sommes parvenue ?

```{python} 
# {.python code-line-numbers="7,11,13" }
#| echo: False
# %%
import pandas as pd
import plotly.graph_objects as go

data = pd.read_csv("../data_visu/Mesure_annuelle_Region_Occitanie_Polluants_Principaux.csv")
df = pd.DataFrame(data)
columns_to_drop = ['code_station', 'typologie', 'influence', 'id_poll_ue', 'unite', 'metrique', 'date_fin', 'statut_valid']
df = df.drop(columns=columns_to_drop)
grouped_df = df.groupby(['date_debut', 'nom_poll'])['valeur'].sum().reset_index()
grouped_df = grouped_df.sort_values(by=['date_debut', 'nom_poll'])
grouped_df['date_debut'] = pd.to_datetime(grouped_df['date_debut'])
grouped_df['date_debut'] = grouped_df['date_debut'].dt.year

fig = go.FigureWidget()
polluants = sorted(grouped_df["nom_poll"].unique())
for polluant in polluants:
    trace_data = grouped_df[grouped_df["nom_poll"] == polluant]
    fig.add_trace(
        go.Scatter(
            x=trace_data["date_debut"],
            y=trace_data["valeur"],
            mode='lines',
            name=f"Polluant = {polluant}",
        )
    )
fig.update_layout(
    template="simple_white",
    title="Polluants en fonction de l'année",
    showlegend=True,
    xaxis_title="Polluants",
    yaxis_title="Fréquence normalisée",
)


fig.show()
```

## Carte 

# Par département 
On va prendre l'exemple de la Haute-Garonne 

## Haute-Garonne 

```{python}
#| echo: False
# %%
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import numpy as np
def plot_polluant_evolution_annuelle(data_file, department, polluants):
    pd.options.mode.chained_assignment = None
    """Cette fonction prend en argument le fichier CSV, le département et la liste des polluants à afficher et affiche l'évolution de la concentration par station de chaque polluants"""
    # Charger les données
    df = pd.read_csv(data_file)
    df["valeur"].fillna(0, inplace=True)
    # Afficher la liste des polluants présents dans le DataFrame
    liste_polluants = df["nom_poll"].unique()

    # Boucle à travers les polluants pour créer les graphiques
    for polluant in polluants:
        # Filtrer les données pour le polluant et le département spécifiés
        filt = df[(df["nom_dept"] == department) & (df["nom_poll"] == polluant)]
        filt = filt.sort_values(by="date_debut")

        # Convertir la colonne de dates au format mois-année
        filt["date_debut"] = (
            pd.to_datetime(filt["date_debut"]).dt.to_period("M").astype(str)
        )

        # Créer un graphique interactif avec Plotly Express
        fig = px.scatter(
            filt,
            x="date_debut",
            y="valeur",
            color="nom_station",
            size="valeur",
            hover_name="date_debut",
            title=f"Évolution de la pollution {polluant} dans le {department}",
            labels={"valeur": f"Valeur {polluant} (ug.m-3)", "date_debut": "Année"},
        )

        # Ajouter des lignes reliant les points pour chaque station
        for nom_station in filt["nom_station"].unique():
            trace_data = filt[filt["nom_station"] == nom_station]
            fig.add_trace(
                go.Scatter(
                    x=trace_data["date_debut"],
                    y=trace_data["valeur"],
                    mode="lines",  # Ajout de ligne pour relier les points
                    showlegend=False,
                )
            )
        fig.show()
plot_polluant_evolution_annuelle("../data_visu/Mesure_annuelle_Region_Occitanie_Polluants_Principaux.csv","HAUTE-GARONNE",['PM2.5'])
```
---

```{python}
#| echo: False
# %%
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
def plot_polluant_evolution_annuelle(data_file, department, polluants):
    pd.options.mode.chained_assignment = None
    """Cette fonction prend en argument le fichier CSV, le département et la liste des polluants à afficher et affiche l'évolution de la concentration par station de chaque polluants"""
    # Charger les données
    df = pd.read_csv(data_file)
    df["valeur"].fillna(0, inplace=True)
    # Afficher la liste des polluants présents dans le DataFrame
    liste_polluants = df["nom_poll"].unique()

    # Boucle à travers les polluants pour créer les graphiques
    for polluant in polluants:
        # Filtrer les données pour le polluant et le département spécifiés
        filt = df[(df["nom_dept"] == department) & (df["nom_poll"] == polluant)]
        filt = filt.sort_values(by="date_debut")

        # Convertir la colonne de dates au format mois-année
        filt["date_debut"] = (
            pd.to_datetime(filt["date_debut"]).dt.to_period("M").astype(str)
        )

        # Créer un graphique interactif avec Plotly Express
        fig = px.scatter(
            filt,
            x="date_debut",
            y="valeur",
            color="nom_station",
            size="valeur",
            hover_name="date_debut",
            title=f"Évolution de la pollution {polluant} dans le {department}",
            labels={"valeur": f"Valeur {polluant} (ug.m-3)", "date_debut": "Année"},
        )

        # Ajouter des lignes reliant les points pour chaque station
        for nom_station in filt["nom_station"].unique():
            trace_data = filt[filt["nom_station"] == nom_station]
            fig.add_trace(
                go.Scatter(
                    x=trace_data["date_debut"],
                    y=trace_data["valeur"],
                    mode="lines",  # Ajout de ligne pour relier les points
                    showlegend=False,
                )
            )
        fig.show()
plot_polluant_evolution_annuelle("../data_visu/Mesure_annuelle_Region_Occitanie_Polluants_Principaux.csv","HAUTE-GARONNE",['PM2.5'])
```


# Par ville 

## Toulouse

```{python}
def polar_plot_mensuelle(ville):  
    pd.options.mode.chained_assignment = None
    # Chargez le fichier CSV dans un DataFrame pandas
    chemin_fichier_csv = r'../data_visu/mensuelle.csv'
    df = pd.read_csv(chemin_fichier_csv)
    df = df.dropna()

    # Convertir la colonne 'date_debut' en type datetime
    df['date_debut'] = pd.to_datetime(df['date_debut'], format='%Y/%m/%d %H:%M:%S%z')

    # Extraire le mois de chaque date
    df['mois'] = df['date_debut'].dt.month

    # Trier le DataFrame par ordre croissant de date
    df = df.sort_values(by='mois')

    # Définir les polluants et la ville spécifiques
    polluants = ['PM10', 'NOX', 'O3', 'NO2', 'PM2.5', 'NO', 'SO2', 'H2S'] 
    # ville = 'TOULOUSE' 

    # Filtrer les données pour inclure uniquement les polluants spécifiés
    df_filtered = df[df['nom_poll'].isin(polluants)]

    # Séparer les données pour la ville spécifiée
    df_ville = df_filtered[df_filtered['nom_com'] == ville]

    # Calculer la moyenne des concentrations de chaque polluant à chaque heure de la journée pour la ville spécifiée
    df_moyennes_ville = df_ville.groupby(['nom_poll', 'mois'])['valeur'].mean().reset_index()
    df_moyennes_ville.columns = ['nom_poll', 'mois', 'moyenne_valeur']

    # Créer un graphique polaire avec Plotly Express
    fig = px.line_polar(df_moyennes_ville, r='moyenne_valeur', theta=df_moyennes_ville['mois']*(360//12), line_close=True,
                        color='nom_poll', line_dash='nom_poll', title=f'Évolution des polluants par mois de la région {ville}')
    liste_des_mois = ["Décembre","Janvier","Février", "Mars","Avril","Mai","Juin","Juillet","Août","Septembre","Octobre","Novembre"]
    fig.update_polars(
        radialaxis=dict(
            visible=False,  # Set to False if you want to hide the radial axis
        ),
        angularaxis=dict(
            visible=True,  # Set to False if you want to hide the angular axis
            rotation=120,   # Rotate the angular axis (default is 0)
            direction='clockwise',  # Set the direction of the angular axis
            period=360,   # Set the period of the angular axis
            tickvals=np.arange(0, 360, 30),
            ticktext=[i for i in liste_des_mois],  # Specify tick values on the angular axis
        )
    )
    # Afficher le graphique
    fig.show()
```

--- 

```{python}
#| echo : False
def polar_plot_mensuelle(ville):  
    pd.options.mode.chained_assignment = None
    # Chargez le fichier CSV dans un DataFrame pandas
    chemin_fichier_csv = r'../data_visu/mensuelle.csv'
    df = pd.read_csv(chemin_fichier_csv)
    df = df.dropna()

    # Convertir la colonne 'date_debut' en type datetime
    df['date_debut'] = pd.to_datetime(df['date_debut'], format='%Y/%m/%d %H:%M:%S%z')

    # Extraire le mois de chaque date
    df['mois'] = df['date_debut'].dt.month

    # Trier le DataFrame par ordre croissant de date
    df = df.sort_values(by='mois')

    # Définir les polluants et la ville spécifiques
    polluants = ['PM10', 'NOX', 'O3', 'NO2', 'PM2.5', 'NO', 'SO2', 'H2S'] 
    # ville = 'TOULOUSE' 

    # Filtrer les données pour inclure uniquement les polluants spécifiés
    df_filtered = df[df['nom_poll'].isin(polluants)]

    # Séparer les données pour la ville spécifiée
    df_ville = df_filtered[df_filtered['nom_com'] == ville]

    # Calculer la moyenne des concentrations de chaque polluant à chaque heure de la journée pour la ville spécifiée
    df_moyennes_ville = df_ville.groupby(['nom_poll', 'mois'])['valeur'].mean().reset_index()
    df_moyennes_ville.columns = ['nom_poll', 'mois', 'moyenne_valeur']

    # Créer un graphique polaire avec Plotly Express
    fig = px.line_polar(df_moyennes_ville, r='moyenne_valeur', theta=df_moyennes_ville['mois']*(360//12), line_close=True,
                        color='nom_poll', line_dash='nom_poll', title=f'Évolution des polluants par mois de la région {ville}')
    liste_des_mois = ["Décembre","Janvier","Février", "Mars","Avril","Mai","Juin","Juillet","Août","Septembre","Octobre","Novembre"]
    fig.update_polars(
        radialaxis=dict(
            visible=False,  # Set to False if you want to hide the radial axis
        ),
        angularaxis=dict(
            visible=True,  # Set to False if you want to hide the angular axis
            rotation=120,   # Rotate the angular axis (default is 0)
            direction='clockwise',  # Set the direction of the angular axis
            period=360,   # Set the period of the angular axis
            tickvals=np.arange(0, 360, 30),
            ticktext=[i for i in liste_des_mois],  # Specify tick values on the angular axis
        )
    )
    # Afficher le graphique
    fig.show()
polar_plot_mensuelle("TOULOUSE")
```

# Problèmes rencontrés 

# Conclusion 
